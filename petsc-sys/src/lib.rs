//! Raw PETSc bindings generated by bindgen.
//!
//! # Features
//! 
//! PETSc has support for multiple different sizes of scalars and integers. To expose this
//! to rust, we require you set different features. The following are all the features that
//! can be set. Note, you are required to have exactly one scalar feature set and exactly
//! one integer feature set. And it must match the PETSc install.
//!
//! - **`petsc-real-f64`** *(enabled by default)* — Sets the real type, [`PetscReal`], to be `f64`.
//! Also sets the complex type, [`PetscComplex`], to be `Complex<f64>`.
//! - **`petsc-real-f32`** — Sets the real type, [`PetscReal`] to be `f32`.
//! Also sets the complex type, [`PetscComplex`], to be `Complex<f32>`.
//! - **`petsc-use-complex`** *(disabled by default)* *(experimental only)* - Sets the scalar type, [`PetscScalar`], to
//! be the complex type, [`PetscComplex`]. If disabled then the scalar type is the real type, [`PetscReal`].
//! You must be using the `complex-scalar` branch to enable this feature.
//! - **`petsc-int-i32`** *(enabled by default)* — Sets the integer type, [`PetscInt`], to be `i32`.
//! - **`petsc-int-i64`** — Sets the integer type, [`PetscInt`], to be `i64`.

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(missing_docs)]
#![allow(deref_nullptr)] // this is done in bindgen tests
include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
include!(concat!(env!("OUT_DIR"), "/enums.rs"));

#[cfg(feature = "petsc-use-complex")]
use num_complex::Complex;

pub const PETSC_DECIDE_INTEGER: PetscInt = PETSC_DECIDE as PetscInt;
pub const PETSC_DEFAULT_INTEGER: PetscInt = PETSC_DEFAULT as PetscInt;
pub const PETSC_DEFAULT_REAL: PetscReal = PETSC_DEFAULT as PetscReal;

// Redefined stuff from `petscpctypes.h`
/// This table is from: <https://petsc.org/release/docs/manualpages/PC/PCType.html#PCType>
pub static PCTYPE_TABLE: &'static [&str] = &[
    "none",
    "jacobi",
    "sor",
    "lu",
    "shell",
    "bjacobi",
    "mg",
    "eisenstat",
    "ilu",
    "icc",
    "asm",
    "gasm",
    "ksp",
    "composite",
    "redundant",
    "spai",
    "nn",
    "cholesky",
    "pbjacobi",
    "vpbjacobi",
    "mat",
    "hypre",
    "parms",
    "fieldsplit",
    "tfs",
    "ml",
    "galerkin",
    "exotic",
    "cp",
    "bfbt",
    "lsc",
    "python",
    "pfmg",
    "syspfmg",
    "redistribute",
    "svd",
    "gamg",
    "chowiluviennacl",
    "rowscalingviennacl",
    "saviennacl",
    "bddc",
    "kaczmarz",
    "telescope",
    "patch",
    "lmvm",
    "hmg",
    "deflation",
    "hpddm",
    "hara"
];

/// Preconditioner type.
///
/// This enum is from: <https://petsc.org/release/docs/manualpages/PC/PCType.html#PCType>
pub enum PCTypeEnum {
    PCNONE = 0,
    PCJACOBI,
    PCSOR,
    PCLU,
    PCSHELL,
    PCBJACOBI,
    PCMG,
    PCEISENSTAT,
    PCILU,
    PCICC,
    PCASM,
    PCGASM,
    PCKSP,
    PCCOMPOSITE,
    PCREDUNDANT,
    PCSPAI,
    PCNN,
    PCCHOLESKY,
    PCPBJACOBI,
    PCVPBJACOBI,
    PCMAT,
    PCHYPRE,
    PCPARMS,
    PCFIELDSPLIT,
    PCTFS,
    PCML,
    PCGALERKIN,
    PCEXOTIC,
    PCCP,
    PCBFBT,
    PCLSC,
    PCPYTHON,
    PCPFMG,
    PCSYSPFMG,
    PCREDISTRIBUTE,
    PCSVD,
    PCGAMG,
    PCCHOWILUVIENNACL,
    PCROWSCALINGVIENNACL,
    PCSAVIENNACL,
    PCBDDC,
    PCKACZMARZ,
    PCTELESCOPE,
    PCPATCH,
    PCLMVM,
    PCHMG,
    PCDEFLATION,
    PCHPDDM,
    PCHARA,
}

// Redefined stuff from `petscpctypes.h`
/// This table is from: <https://petsc.org/release/docs/manualpages/PC/PCType.html#PCType>
pub static DMTYPE_TABLE: &'static [&str] = &[
    "da",
    "composite",
    "sliced",
    "shell",
    "plex",
    "redundant",
    "patch",
    "moab",
    "network",
    "forest",
    "p4est",
    "p8est",
    "swarm",
    "product",
    "stag",
];

/// This enum is from: <https://petsc.org/release/docs/manualpages/DM/DMType.html#DMType>
pub enum DMTypeEnum {
    DMDA = 0,
    DMCOMPOSITE,
    DMSLICED,
    DMSHELL,
    DMPLEX,
    DMREDUNDANT,
    DMPATCH,
    DMMOAB,
    DMNETWORK,
    DMFOREST,
    DMP4EST,
    DMP8EST,
    DMSWARM,
    DMPRODUCT,
    DMSTAG,
}

// Redefined stuff from `petscfe.h`
/// This table is from: <https://petsc.org/release/docs/manualpages/FE/PetscSpaceType.html>
pub static PETSCSPACETYPE_TABLE: &'static [&str] = &[
    "poly",
    "tensor",
    "sum",
    "point",
    "subspace",
];

/// This enum is from: <https://petsc.org/release/docs/manualpages/FE/PetscSpaceType.html>
pub enum PetscSpaceTypeEnum {
    PETSCSPACEPOLYNOMIAL = 0,
    PETSCSPACETENSOR,
    PETSCSPACESUM,
    PETSCSPACEPOINT,
    PETSCSPACESUBSPACE,
}

// Redefined stuff from `petscfe.h`
/// This table is from: <https://petsc.org/release/docs/manualpages/FE/PetscSpaceType.html>
pub static PETSCDUALSPACETYPE_TABLE: &'static [&str] = &[
    "lagrange",
    "simple",
    "refined",
    "bdm",
];

/// This enum is from: <https://petsc.org/release/docs/manualpages/FE/PetscSpaceType.html>
pub enum PetscDualSpaceTypeEnum {
    PETSCDUALSPACELAGRANGE = 0,
    PETSCDUALSPACESIMPLE,
    PETSCDUALSPACEREFINED,
    PETSCDUALSPACEBDM,
}

// TODO: num_complex::Complex docs say:
// "Note that Complex<F> where F is a floating point type is only memory layout compatible with C’s
// complex types, not necessarily calling convention compatible. This means that for FFI you can
// only pass Complex<F> behind a pointer, not as a value."
// What does this mean for use? If every function is listed as `extern "C"` are we ok?
// Petsc function dont take pointers as inputs all the time.
#[cfg(feature = "petsc-use-complex")]
impl Into<Complex<PetscReal>> for __BindgenComplex<PetscReal> {
    fn into(self) -> Complex<PetscReal> {
        // This should be safe because `__BindgenComplex<T>` and `Complex<T>` are both
        // memory layout compatible with an array [T; 2]
        unsafe { std::mem::transmute(self) }
    }
}

#[cfg(feature = "petsc-use-complex")]
impl From<Complex<PetscReal>> for __BindgenComplex<PetscReal> {
    fn from(ct: Complex<PetscReal>) -> __BindgenComplex<PetscReal> {
        // This should be safe because `__BindgenComplex` and `Complex` are both
        // memory layout compatible with an array [T; 2]
        unsafe { std::mem::transmute(ct) }
    }
}

impl Into<bool> for PetscBool {
    fn into(self) -> bool {
        match self {
            PetscBool::PETSC_FALSE => false,
            PetscBool::PETSC_TRUE => true
        }
    }
}

impl From<bool> for PetscBool {
    fn from(b: bool) -> Self {
        match b {
            false => PetscBool::PETSC_FALSE,
            true => PetscBool::PETSC_TRUE
        }
    }
}

// TODO: add more, or maybe use a derive macro or something (maybe try strum_macros)
impl std::str::FromStr for DMBoundaryType {
    type Err = std::io::Error;
    fn from_str(input: &str) -> std::result::Result<DMBoundaryType, std::io::Error> {
        let dm_types_p = unsafe { DMBoundaryTypes.as_ptr() };
        let dm_types_slice =  unsafe { std::slice::from_raw_parts(dm_types_p, 5) };
        if input.to_uppercase().as_str() 
            == unsafe { std::ffi::CStr::from_ptr(dm_types_slice[DMBoundaryType::DM_BOUNDARY_NONE as usize]) }.to_str().unwrap() {
            Ok(DMBoundaryType::DM_BOUNDARY_NONE)
        } else if input.to_uppercase().as_str() 
            == unsafe { std::ffi::CStr::from_ptr(dm_types_slice[DMBoundaryType::DM_BOUNDARY_GHOSTED as usize]) }.to_str().unwrap() {
            Ok(DMBoundaryType::DM_BOUNDARY_GHOSTED)
        } else if input.to_uppercase().as_str() 
            == unsafe { std::ffi::CStr::from_ptr(dm_types_slice[DMBoundaryType::DM_BOUNDARY_MIRROR as usize]) }.to_str().unwrap() {
            Ok(DMBoundaryType::DM_BOUNDARY_MIRROR)
        } else if input.to_uppercase().as_str() 
            == unsafe { std::ffi::CStr::from_ptr(dm_types_slice[DMBoundaryType::DM_BOUNDARY_PERIODIC as usize]) }.to_str().unwrap() {
            Ok(DMBoundaryType::DM_BOUNDARY_PERIODIC)
        } else if input.to_uppercase().as_str() 
            == unsafe { std::ffi::CStr::from_ptr(dm_types_slice[DMBoundaryType::DM_BOUNDARY_TWIST as usize]) }.to_str().unwrap() {
            Ok(DMBoundaryType::DM_BOUNDARY_TWIST)
        } else {
            Err(std::io::Error::new(std::io::ErrorKind::InvalidInput, format!("{}, is not valid", input)))
        }
    }
}

impl std::fmt::Display for DMBoundaryType {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        // SAFETY: this c array is defined in dm.c and is defined to be of size 8.
        // But the header petscdm.h (and then bindgen) defines it as size 0 array.
        // Thus we have to trick rust into thinking it is size 5, becayse that's all
        // we care about.
        let dm_types_p = unsafe { DMBoundaryTypes.as_ptr() };
        let dm_types_slice =  unsafe { std::slice::from_raw_parts(dm_types_p, 5) };
        write!(f, "{}", unsafe { 
            std::ffi::CStr::from_ptr(dm_types_slice[*self as usize]) }.to_str().unwrap())
    }
}

impl Default for DMBoundaryType {
    fn default() -> Self { DMBoundaryType::DM_BOUNDARY_NONE }
}
